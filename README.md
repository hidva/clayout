clayout, translate C++/Rust type into C type with the same memory layout. Generally, clayout is used together with bpftrace.

clayout is developed on [ddbug](https://github.com/gimli-rs/ddbug). THANKS FOR ddbug!

# Usage

Imagine a scenario where you want to use bpftrace to track the value of `S::x` during the running of the following program.

```c++
#include <stdio.h>
#include <unistd.h>

struct X {
  virtual ~X() {}

  int x1;
};

struct S : public X {
  S() : x(0) {}

  S(const S &other) : x(other.x) {}

  S f(int y, int z) {
    printf("output from a.out: this.x=%d y=%d z=%d\n", x, y, z);
    x += (y + z);
    return *this;
  }

  int x;
};

int main(int argc, char **argv) {
  S s;
  int i = 0;
  while (1) {
    s.f(i, i);
    ++i;
    sleep(1);
    // break;
  }
  return 0;
}
```

clayout can translate `S` into a C structure with the same memory layout:

```
# clayout will generate struct.h, struct.c
$ clayout -i ${binary path} -o struct S
```

```C
// struct.h
// Generated by hidva/clayout! 大吉大利!
#pragma once
#include <linux/types.h>
struct HidvaStruct2 {
  void** __mem1;
  int x1;
} __attribute__((__packed__));


struct S {
  struct HidvaStruct2 __parent0;
  int x;
} __attribute__((__packed__));
```

So you can easily write the following bpftrace script:

```bpftrace
#include "struct.h"

u:/apsara/zhanyi.ww/tmp/bphtrace/x/trace:_ZN1S1fEii {
  printf("output from bpftrace: ret=%p this.x=%d y=%d z=%d\n", (int32*)arg0, ((struct S*)arg1)->x, arg2, arg3)
}
```

```
$ bpftrace  -c ./trace t.bt
Attaching 1 probe...
output from a.out: this.x=0 y=0 z=0
output from bpftrace: ret=0x7ffff3044610 this.x=0 y=0 z=0
output from a.out: this.x=0 y=1 z=1
output from bpftrace: ret=0x7ffff3044610 this.x=0 y=1 z=1
```

Please note that you may intuitively think that the layout of S is as follows:

```C
struct X {
  void** __mem1;
  int x1;
}

struct S {
  struct X __parent0;
  int x;
}
```

But actually it is wrong! `S::x` will reuse the padding part of `X` in C++!
